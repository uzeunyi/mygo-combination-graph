<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>멤버 조합 티어 메이커 📊</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e6f9ff 0%, #cdf2ff 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        @media (min-width: 1200px) {
            .main-content {
                flex-direction: row;
            }
            
            .tier-section {
                flex: 1;
            }
            
            .graph-section {
                flex: 1;
            }
        }

        h1 {
            text-align: center;
            color: #1e88e5;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        /* 멤버 관리 섹션 */
        .member-section {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(214, 51, 132, 0.1);
        }

        .member-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        input[type="text"] {
            flex: 1;
            padding: 12px;
            border: 2px solid #f8d7da;
            border-radius: 8px;
            font-size: 16px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #1e88e5;
        }

        button {
            padding: 12px 20px;
            background: #1e88e5;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }

        button:hover {
            background: #1565c0;
            transform: translateY(-2px);
        }

        .members-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .member-tag {
            background: #f8d7da;
            color: #721c24;
            padding: 8px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .member-face {
            width: 30px;
            height: 30px;
            object-fit: cover;
            object-position: center 0%;
            border-radius: 50%;
            border: 2px solid #1e88e5;
        }

        .combo-faces {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .combo-face {
            width: 40px;
            height: 40px;
            object-fit: cover;
            object-position: center 10%;
            border-radius: 50%;
            border: 2px solid #1e88e5;
        }

        .combo-card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .combo-member {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .combo-member-name {
            font-size: 10px;
            color: #666;
            font-weight: 500;
        }

        .node-face {
            width: 40px;
            height: 40px;
            object-fit: cover;
            object-position: center 10%;
            border-radius: 50%;
            border: 3px solid #d63384;
        }

        .member-tag .remove {
            cursor: pointer;
            font-weight: bold;
            color: #1e88e5;
        }

        /* 티어 메이커 섹션 */
        .tier-section {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(30, 136, 229, 0.1);
        }

        .combinations-pool {
            background: #f0faff;
            border: 2px dashed #1e88e5;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            min-height: 120px;
        }

        .combination-card {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: white;
            padding: 8px;
            margin: 5px;
            border-radius: 12px;
            border: 2px solid #bbdefb;
            cursor: grab;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(30, 136, 229, 0.1);
            min-width: 100px;
        }

        .combination-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(30, 136, 229, 0.2);
        }

        .combination-card.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .tier-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            min-height: 80px;
        }

        .tier-label {
            width: 140px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            border-radius: 10px;
            margin-right: 15px;
            color: #333;
        }

        .tier-s {
            background: linear-gradient(45deg, #ffb3d9, #ffc7e6);
        }

        .tier-a {
            background: linear-gradient(45deg, #fff2b3, #fff8d1);
        }

        .tier-b {
            background: linear-gradient(45deg, #b3d9ff, #d1e8ff);
        }

        .tier-c {
            background: linear-gradient(45deg, #d9d9d9, #e8e8e8);
        }

        .tier-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.7);
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 15px;
            min-height: 60px;
            transition: all 0.3s;
        }

        .tier-content.drag-over {
            border-color: #1e88e5;
            background: rgba(30, 136, 229, 0.1);
        }

        /* 그래프 섹션 */
        .graph-section {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(30, 136, 229, 0.1);
        }

        .graph-controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .tier-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tier-toggle input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        #graph-container {
            width: 100%;
            height: 500px;
            border: 2px solid #bbdefb;
            border-radius: 10px;
            background: white;
        }

        .node {
            cursor: pointer;
        }

        .link {
            transition: opacity 0.3s;
        }

        .link.highlighted {
            stroke-width: 4;
            opacity: 1 !important;
        }

        .link.dimmed {
            opacity: 0.1;
        }

        .node-label {
            font-size: 14px;
            font-weight: bold;
            fill: #333;
            text-anchor: middle;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>🎸 MyGO!!!!! 좋아하는 조합 그래프 📈</h1>
        
        <div class="main-content">
            <!-- 티어 메이커 섹션 -->
            <div class="tier-section">
                <div class="combinations-pool" id="combinationsPool">
                    <p style="color: #666; text-align: center;">조합을 드래그해서 티어를 만들어보세요!</p>
                </div>

                <!-- 순서 바꾸기 영역 -->
                <div style="background: #fff3cd; border: 2px dashed #856404; border-radius: 10px; padding: 15px; margin-bottom: 20px; text-align: center; min-height: 80px; display: flex; flex-direction: column; justify-content: center;" id="swapArea">
                    <p style="color: #856404; font-weight: bold; margin: 0;">💫 순서 바꾸기</p>
                    <p style="color: #856404; font-size: 12px; margin: 5px 0 0 0;">조합을 여기에 드래그하면 순서가 바뀝니다</p>
                </div>

                <div class="tier-row">
                    <div class="tier-label tier-s">최애 커플</div>
                    <div class="tier-content" data-tier="S"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-a">좋아하는 커플</div>
                    <div class="tier-content" data-tier="A"></div>
                </div>
                <div class="tier-row">
                    <div class="tier-label tier-b">좋아하는 조합</div>
                    <div class="tier-content" data-tier="B"></div>
                </div>
                <div class="tier-row">
                            <div class="tier-label tier-c">못 보는 커플</div>
                            <div class="tier-content" data-tier="C"></div>
                        </div>
            </div>

            <!-- 그래프 섹션 -->
            <div class="graph-section">
                <div class="graph-controls">
                    <span>티어 표시:</span>
                    <div class="tier-toggle">
                        <input type="checkbox" id="toggle-S" checked />
                        <label for="toggle-S" style="color: #ff69b4; font-weight: bold;">최애 커플</label>
                    </div>
                    <div class="tier-toggle">
                        <input type="checkbox" id="toggle-A" checked />
                        <label for="toggle-A" style="color: #ffd700; font-weight: bold;">좋아하는 커플</label>
                    </div>
                    <div class="tier-toggle">
                        <input type="checkbox" id="toggle-B" checked />
                        <label for="toggle-B" style="color: #4169e1; font-weight: bold;">좋아하는 조합</label>
                    </div>
                    <div class="tier-toggle">
                        <input type="checkbox" id="toggle-C" checked />
                        <label for="toggle-C" style="color: #888888; font-weight: bold;">못 보는 커플</label>
                    </div>
                </div>
                <div id="graph-container"></div>
            </div>
        </div>
    </div>

    <script>
        let members = [];
        let combinations = [];
        let tierData = { S: [], A: [], B: [], C: [] };
        let simulation, svg, nodesGroup, linksGroup;

        // 멤버 이름을 파일명으로 매핑
        const memberToFilename = {
            '토모리': 'tomori',
            '타키': 'taki', 
            '소요': 'soyo',
            '아논': 'anon',
            '라나': 'rana'
        };

        // 멤버별 색상 정의
        const memberColors = {
            '토모리': '#77BBDD',
            '타키': '#7777AA', 
            '소요': '#FFDD88',
            '아논': '#FF8899',
            '라나': '#77DD77'
        };

        function getMemberImage(memberName) {
            const filename = memberToFilename[memberName] || memberName.toLowerCase();
            return `asset/${filename}_face.webp`;
        }

        function getMemberColor(memberName) {
            return memberColors[memberName] || '#1e88e5';
        }

        const tierColors = {
            S: '#ff69b4',
            A: '#ffd700',
            B: '#4169e1',
            C: '#888888'
        };

        // 멤버 추가 (필요시)
        function addMember() {
            const input = document.getElementById('memberInput');
            if (!input) return; // 입력창이 없으면 무시
            const memberName = input.value.trim();

            if (memberName && !members.includes(memberName)) {
                members.push(memberName);
                input.value = '';
                generateCombinations();
            }
        }

        // 멤버 삭제 (필요시)
        function removeMember(memberName) {
            members = members.filter(m => m !== memberName);
            generateCombinations();
        }

        // 조합 생성
        function generateCombinations() {
            combinations = [];
            for (let i = 0; i < members.length; i++) {
                for (let j = i + 1; j < members.length; j++) {
                    combinations.push([members[i], members[j]]);
                }
            }

            // 조합 셔플
            for (let i = combinations.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [combinations[i], combinations[j]] = [combinations[j], combinations[i]];
            }

            // 기존 티어 데이터 초기화
            tierData = { S: [], A: [], B: [], C: [] };

            updateCombinationsPool();
            updateGraph();
        }

        // 조합 풀 업데이트
        function updateCombinationsPool() {
            const pool = document.getElementById('combinationsPool');

            if (combinations.length === 0) {
                pool.innerHTML = '<p style="color: #666; text-align: center;">조합을 드래그해서 티어를 만들어보세요!</p>';
                return;
            }

            pool.innerHTML = combinations.map(combo => {
                return `<div class="combination-card" draggable="true" data-combo="${combo.join(' × ')}">
                    <div class="combo-member">
                        <div class="combo-member-name">${combo[0]}</div>
                        <img src="${getMemberImage(combo[0])}" alt="${combo[0]}" class="combo-face" style="border-color: ${getMemberColor(combo[0])}" onerror="this.style.display='none'">
                    </div>
                    <div class="combo-member">
                        <div class="combo-member-name">${combo[1]}</div>
                        <img src="${getMemberImage(combo[1])}" alt="${combo[1]}" class="combo-face" style="border-color: ${getMemberColor(combo[1])}" onerror="this.style.display='none'">
                    </div>
                </div>`;
            }).join('');

            // 드래그 이벤트 설정
            setupDragAndDrop();
        }

        // 드래그 앤 드롭 설정
        function setupDragAndDrop() {
            const cards = document.querySelectorAll('.combination-card');
            const tierContents = document.querySelectorAll('.tier-content');
            const swapArea = document.getElementById('swapArea');

            cards.forEach(card => {
                card.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', card.dataset.combo);
                    card.classList.add('dragging');
                });

                card.addEventListener('dragend', e => {
                    card.classList.remove('dragging');
                });
            });

            tierContents.forEach(content => {
                content.addEventListener('dragover', e => {
                    e.preventDefault();
                    content.classList.add('drag-over');
                });

                content.addEventListener('dragleave', e => {
                    content.classList.remove('drag-over');
                });

                content.addEventListener('drop', e => {
                    e.preventDefault();
                    content.classList.remove('drag-over');

                    const comboText = e.dataTransfer.getData('text/plain');
                    const tier = content.dataset.tier;

                    // 기존 티어에서 제거
                    Object.keys(tierData).forEach(t => {
                        tierData[t] = tierData[t].filter(combo => combo !== comboText);
                    });

                    // 새 티어에 추가
                    if (!tierData[tier].includes(comboText)) {
                        tierData[tier].push(comboText);
                    }

                    updateTierDisplay();
                    updateGraphElements(); // 전체 그래프 재생성 대신 업데이트만
                });
            });

            // 순서 바꾸기 영역
            swapArea.addEventListener('dragover', e => {
                e.preventDefault();
                swapArea.style.background = '#ffeaa7';
            });

            swapArea.addEventListener('dragleave', e => {
                swapArea.style.background = '#fff3cd';
            });

            swapArea.addEventListener('drop', e => {
                e.preventDefault();
                e.stopPropagation();
                swapArea.style.background = '#fff3cd';
                
                const comboText = e.dataTransfer.getData('text/plain');
                if (!comboText) return;
                
                const [member1, member2] = comboText.split(' × ');
                const swappedCombo = `${member2} × ${member1}`;
                
                // 티어에서 제거
                Object.keys(tierData).forEach(tier => {
                    tierData[tier] = tierData[tier].filter(combo => combo !== comboText);
                });
                
                // 조합 배열에서 순서 바꾸기
                const comboIndex = combinations.findIndex(combo => 
                    combo.join(' × ') === comboText
                );
                if (comboIndex !== -1) {
                    combinations[comboIndex] = [member2, member1];
                }
                
                updateTierDisplay();
                updateCombinationsPool();
                updateGraphElements();
            });

            // 풀로 다시 드래그할 수 있게
            const pool = document.getElementById('combinationsPool');
            pool.addEventListener('dragover', e => e.preventDefault());
            pool.addEventListener('drop', e => {
                e.preventDefault();
                const comboText = e.dataTransfer.getData('text/plain');

                // 모든 티어에서 제거
                Object.keys(tierData).forEach(t => {
                    tierData[t] = tierData[t].filter(combo => combo !== comboText);
                });

                updateTierDisplay();
                updateGraphElements();
            });
        }

        // 티어 표시 업데이트
        function updateTierDisplay() {
            Object.keys(tierData).forEach(tier => {
                const content = document.querySelector(`[data-tier="${tier}"]`);
                content.innerHTML = tierData[tier].map(combo => {
                    const [member1, member2] = combo.split(' × ');
                    return `<div class="combination-card" draggable="true" data-combo="${combo}">
                        <div class="combo-member">
                            <div class="combo-member-name">${member1}</div>
                            <img src="${getMemberImage(member1)}" alt="${member1}" class="combo-face" style="border-color: ${getMemberColor(member1)}" onerror="this.style.display='none'">
                        </div>
                        <div class="combo-member">
                            <div class="combo-member-name">${member2}</div>
                            <img src="${getMemberImage(member2)}" alt="${member2}" class="combo-face" style="border-color: ${getMemberColor(member2)}" onerror="this.style.display='none'">
                        </div>
                    </div>`;
                }).join('');
            });

            // 풀에서 이미 배치된 조합들 제거
            const placedCombos = Object.values(tierData).flat();
            const pool = document.getElementById('combinationsPool');
            const remainingCombos = combinations.filter(combo => {
                const comboText = combo.join(' × ');
                const reverseComboText = `${combo[1]} × ${combo[0]}`;
                // 조합 또는 역순 조합이 티어에 배치되었는지 확인
                return !placedCombos.some(placed => 
                    placed === comboText || placed === reverseComboText
                );
            });

            if (remainingCombos.length === 0) {
                pool.innerHTML = '<p style="color: #666; text-align: center;">모든 조합이 배치되었습니다! 🎉</p>';
            } else {
                pool.innerHTML = remainingCombos.map(combo =>
                    `<div class="combination-card" draggable="true" data-combo="${combo.join(' × ')}">
                        <div class="combo-member">
                            <div class="combo-member-name">${combo[0]}</div>
                            <img src="${getMemberImage(combo[0])}" alt="${combo[0]}" class="combo-face" style="border-color: ${getMemberColor(combo[0])}" onerror="this.style.display='none'">
                        </div>
                        <div class="combo-member">
                            <div class="combo-member-name">${combo[1]}</div>
                            <img src="${getMemberImage(combo[1])}" alt="${combo[1]}" class="combo-face" style="border-color: ${getMemberColor(combo[1])}" onerror="this.style.display='none'">
                        </div>
                    </div>`
                ).join('');
            }

            setupDragAndDrop();
        }

        // 그래프 업데이트
        function updateGraph() {
            if (members.length === 0) return;

            const container = document.getElementById('graph-container');
            container.innerHTML = '';

            const width = container.offsetWidth;
            const height = container.offsetHeight;

            svg = d3.select('#graph-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // 노드 데이터 (원형으로 고정 배치)
            const radius = Math.min(width, height) * 0.3;
            const centerX = width / 2;
            const centerY = height / 2;
            const nodes = members.map((member, index) => {
                const angle = (index / members.length) * 2 * Math.PI;
                return {
                    id: member,
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle),
                    fx: centerX + radius * Math.cos(angle), // 고정
                    fy: centerY + radius * Math.sin(angle)  // 고정
                };
            });

            // 링크 데이터 (티어별로 색상 구분)
            const links = [];
            Object.keys(tierData).forEach(tier => {
                tierData[tier].forEach(comboText => {
                    const [source, target] = comboText.split(' × ');
                    links.push({
                        source: source,
                        target: target,
                        tier: tier,
                        color: tierColors[tier]
                    });
                });
            });

            // 시뮬레이션 설정 (노드 고정으로 단순화)
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id))
                .stop(); // 애니메이션 중지

            // 링크 force 실행해서 source/target을 객체로 변환
            simulation.force('link').initialize(nodes);
            simulation.force('link').links(links);

            // 링크 그리기
            linksGroup = svg.append('g');

            // 노드 그리기
            nodesGroup = svg.append('g');

            updateGraphElements();
        }

        function updateGraphElements() {
            const links = [];
            Object.keys(tierData).forEach(tier => {
                const checkbox = document.getElementById(`toggle-${tier}`);
                if (checkbox && checkbox.checked) {
                    tierData[tier].forEach(comboText => {
                        const [source, target] = comboText.split(' × ');
                        // 노드 객체 직접 참조
                        const sourceNode = simulation.nodes().find(n => n.id === source);
                        const targetNode = simulation.nodes().find(n => n.id === target);
                        if (sourceNode && targetNode) {
                            links.push({
                                source: sourceNode,
                                target: targetNode,
                                tier: tier,
                                color: tierColors[tier]
                            });
                        }
                    });
                }
            });

            // 링크 업데이트
            const linkSelection = linksGroup.selectAll('line')
                .data(links);

            linkSelection.exit().remove();

            linkSelection.enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke-width', 3)
                .merge(linkSelection)
                .attr('stroke', d => d.color)
                .attr('opacity', 0.7)
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            // 노드 업데이트
            const nodeSelection = nodesGroup.selectAll('g')
                .data(simulation.nodes());

            nodeSelection.exit().remove();

            const nodeEnter = nodeSelection.enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .on('mouseover', handleNodeHover)
                .on('mouseout', handleNodeOut);

            // 노드 이미지 추가
            nodeEnter.append('clipPath')
                .attr('id', d => `clip-${d.id}`)
                .append('circle')
                .attr('r', 30);

            nodeEnter.append('image')
                .attr('xlink:href', d => getMemberImage(d.id))
                .attr('x', -30)
                .attr('y', -30)
                .attr('width', 60)
                .attr('height', 60)
                .attr('clip-path', d => `url(#clip-${d.id})`)
                .attr('preserveAspectRatio', 'xMidYMin slice');

            // 노드 테두리 원
            nodeEnter.append('circle')
                .attr('r', 30)
                .attr('fill', 'none')
                .attr('stroke', d => getMemberColor(d.id))
                .attr('stroke-width', 3);
        }

        function handleNodeHover(event, d) {
            // 관련된 모든 링크 하이라이트
            linksGroup.selectAll('line')
                .classed('highlighted', link => link.source.id === d.id || link.target.id === d.id)
                .classed('dimmed', link => link.source.id !== d.id && link.target.id !== d.id);
        }

        function handleNodeOut() {
            // 하이라이트 제거
            linksGroup.selectAll('line')
                .classed('highlighted', false)
                .classed('dimmed', false);
        }

        // 티어 토글 이벤트
        document.querySelectorAll('[id^="toggle-"]').forEach(checkbox => {
            checkbox.addEventListener('change', updateGraphElements);
        });

        // 엔터키로 멤버 추가 (없는 요소이므로 제거)
        // document.getElementById('memberInput').addEventListener('keypress', e => {
        //     if (e.key === 'Enter') {
        //         addMember();
        //     }
        // });

        // 초기 멤버 설정 (MyGO!!!!! 멤버들)
        members = ['토모리', '타키', '소요', '아논', '라나'];
        generateCombinations();
    </script>
</body>

</html>